package com.clarkparsia.protege.reasoner;

import java.io.Serializable;
import java.util.UUID;

import org.mindswap.pellet.utils.DurationFormat;
import org.mindswap.pellet.utils.progress.ProgressMonitor;
import org.mindswap.pellet.utils.progress.SilentProgressMonitor;

import edu.stanford.smi.protege.exception.ProtegeException;
import edu.stanford.smi.protege.model.KnowledgeBase;
import edu.stanford.smi.protege.model.Localizable;

/**
 * Title: ReasonerStatus<br>
 * Description: Simple status object to be sent over the wire from the server to the client to notify the client on the
 * progress of a job running on the server.<br>
 * Company: Clark & Parsia, LLC. <http://www.clarkparsia.com> <br>
 * Created: Oct 9, 2008 3:08:45 PM
 * Copyright (c) 2008 Clark & Parsia, LLC.
 *
 * @author Michael Grove <mike@clarkparsia.com>
 */
public class ReasonerStatus implements Localizable, Serializable {

	/**
	 * Autogenerated
	 */
	private static final long serialVersionUID = -4253446422472974668L;

	/**
     * The states the reasoner job could be in
     */
    public enum ReasonerState {
        /**
         * Job not started, or is not scheduled.
         */
        Normal,

        /**
         * Job finished successfully
         */
        Complete,

        /**
         * Job is still running
         */
        Busy,

        /**
         * Job failed, possibly with an exception
         * #see getException
         */
        Failed,

        /**
         * Job was aborted and is no longer running.
         */
        Aborted
    }

    /**
     * UUID for this job.
     */
    private UUID mUUID = UUID.randomUUID();

    /**
     * Current status message for displaying to the client
     */
    private String mMessage;

    /**
     * Current state of the job this status object describes
     */
    private ReasonerState mState = ReasonerState.Normal;

    /**
     * The exception that occurred when the job failed.
     */
    private ProtegeException mException;
    
    /**
     * The progress of the reasoning task
     */
    private int mProgress;

    /**
     * Create a new reasoner status
     * @param theState the initial state
     */
    ReasonerStatus(ReasonerState theState) {
    	mState = theState;
    }

    /**
     * Create a new reasoner status
     * @param theState the initial state
     * @param theMessage the initial status message
     */
    ReasonerStatus(ReasonerState theState, String theMessage) {
        mState = theState;
        mMessage = theMessage;
    }

    /**
     * Get the progress
     * @return the progress
     */
    public int getProgress() {
    	return mProgress;
    }
    
    /**
     * Increemnt the progress
     */
    public void incrementProgress() {
    	mProgress++;
    }
    
    /**
     * Reset the progress to 0
     */
    public void resetProgress() {
    	mProgress = 0;
    }
    
    /**
     * Get the current status message
     * @return the status message
     */
    public String getMessage() {
    	return mMessage;
    }

    /**
     * Sets the current status message
     * @param theMsg the new status message
     */
    public void setMessage(String theMsg) {
        mMessage = theMsg;
    }

    /**
     * Marks this status object as completed successfully
     */
    public void complete() {
        if (isBusy() || isNormal()) {
            mState = ReasonerState.Complete;
        }
    }

    /**
     * Marks this status object as aborted
     */
    public void aborted() {
        if (isBusy() || isNormal()) {
            mState = ReasonerState.Aborted;
            setMessage("Reasoner Task Aborted");
        }
    }

    /**
     * Returns whether or not the job is busy, ie if its still running
     * @return true if its still running, false otherwise
     */
    public boolean isBusy() {
        return mState == ReasonerState.Busy;
    }

    /**
     * Returns whether or not the job failed
     * @return true if it failed, false otherwise
     */
    public boolean isFailed() {
        return mState == ReasonerState.Failed;
    }

    /**
     * Returns whether or not the job is in the normal state, ie not started.
     * @return true if it hasn't been started, false otherwse
     */
    public boolean isNormal() {
        return mState == ReasonerState.Normal;
    }

    public void localize(KnowledgeBase kb) {
		// No-op. Only present to avoid the logging a warning message.
	}

    /**
     * Returns whether or not the job completed successfully
     * @return true if it was completed successfully, false otherwise
     */
    public boolean isComplete() {
        return mState == ReasonerState.Complete;
    }

    /**
     * Return whether or not the job was aborted
     * @return true if it was aborted, false otherwise
     */
    public boolean isAborted() {
        return mState == ReasonerState.Aborted;
    }

    /**
     * Returns the exception throw, if one was thrown, when the job failed.  This will always return null if the job
     * is not in the fail state
     * @return the thrown exception, or null if one was not thrown, or the job is not in a failed state
     */
    public ProtegeException getException() {
        return mException;
    }

    /**
     * Sets the job as failed, with the given cause
     * @param theError the cause of the error, if there was one, or null otherwise.
     */
    public void fail(ProtegeException theError) {
        mException = theError;
        mState = ReasonerState.Failed;
    }

    /**
     * Returns the UUID of the job
     * @return the job's UUID
     */
    public UUID getUUID() {
        return mUUID;
    }

    /**
     * @inheritDoc
     */
    @Override
    public boolean equals(Object theObject) {
        return theObject instanceof ReasonerStatus && getUUID().equals(((ReasonerStatus) theObject).getUUID());
    }

    /**
     * @inheritDoc
     */
    @Override
    public int hashCode() {
        return getUUID().hashCode();
    }

    /**
     * @inheritDoc
     */
    @Override
    public String toString() {
        return "ReasonerStatus(" + getUUID() + ") - State: " + mState + " Message: " + (getMessage() == null ? "NONE" : getMessage());
    }
}
